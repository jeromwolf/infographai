/**
 * Simple Video Generation Service
 * Creates video content without complex dependencies
 */

import { prisma } from '../lib/database';
import OpenAI from 'openai';
import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || 'sk-test-key' // Will use mock mode if no key
});

interface Scene {
  id: string;
  type: string;
  duration: number;
  narration: string;
  title?: string;
  subtitle?: string;
}

export class SimpleVideoGenerator {
  private videoId: string;
  private projectId: string;
  private scenarioId?: string;
  private outputDir: string;

  constructor(videoId: string, projectId: string, scenarioId?: string) {
    this.videoId = videoId;
    this.projectId = projectId;
    this.scenarioId = scenarioId;
    this.outputDir = path.join(process.cwd(), 'temp', videoId);
  }

  async generate(): Promise<void> {
    try {
      console.log(`[VideoGen] Starting generation for ${this.videoId}`);
      
      // Update status to PROCESSING
      await this.updateVideoStatus('PROCESSING', 10);

      // Step 1: Generate or fetch script
      const scenes = await this.generateScript();
      await this.updateVideoStatus('PROCESSING', 30);

      // Step 2: Generate subtitles
      await this.generateSubtitles(scenes);
      await this.updateVideoStatus('PROCESSING', 50);

      // Step 3: Create simple video frames
      await this.createSimpleFrames(scenes);
      await this.updateVideoStatus('PROCESSING', 70);

      // Step 4: Create video file (or mock it)
      const videoUrl = await this.createVideo();
      await this.updateVideoStatus('PROCESSING', 90);

      // Step 5: Finalize
      await this.finalizeVideo(videoUrl);

      console.log(`[VideoGen] Completed for ${this.videoId}`);
    } catch (error) {
      console.error('[VideoGen] Failed:', error);
      await this.updateVideoStatus('FAILED', 0, error.message);
      throw error;
    }
  }

  private async generateScript(): Promise<Scene[]> {
    // If we have a scenario, use it
    if (this.scenarioId) {
      const scenario = await prisma.scenario.findUnique({
        where: { id: this.scenarioId }
      });
      
      if (scenario?.scenes) {
        const scenes = typeof scenario.scenes === 'string' 
          ? JSON.parse(scenario.scenes) 
          : scenario.scenes;
        
        return scenes.map((scene: any, index: number) => ({
          id: `scene_${index}`,
          type: scene.type || 'content',
          duration: scene.duration || 5,
          narration: scene.narration || scene.text || `Scene ${index + 1}`,
          title: scene.title,
          subtitle: scene.subtitle
        }));
      }
    }

    // Get video details
    const video = await prisma.video.findUnique({
      where: { id: this.videoId }
    });

    // Generate mock scenes for demo
    const topic = video?.topic || 'Technology';
    
    // Try to use OpenAI if API key exists
    if (process.env.OPENAI_API_KEY) {
      try {
        const completion = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          messages: [
            {
              role: 'system',
              content: 'Generate a simple video script with 3-5 scenes. Return JSON array of scenes with: type, duration (seconds), narration, title.'
            },
            {
              role: 'user',
              content: `Create a short educational video script about: ${topic}`
            }
          ],
          temperature: 0.7,
          max_tokens: 500
        });

        const content = completion.choices[0].message.content;
        if (content) {
          try {
            return JSON.parse(content);
          } catch {
            // If parsing fails, use mock data
          }
        }
      } catch (error) {
        console.log('[VideoGen] OpenAI generation failed, using mock data');
      }
    }

    // Return mock scenes if OpenAI fails or no API key
    return [
      {
        id: 'scene_0',
        type: 'title',
        duration: 3,
        narration: `Welcome to our video about ${topic}`,
        title: topic,
        subtitle: 'An Educational Video'
      },
      {
        id: 'scene_1',
        type: 'content',
        duration: 5,
        narration: `${topic} is an important concept in modern technology.`,
        title: 'Introduction',
        subtitle: 'Understanding the basics'
      },
      {
        id: 'scene_2',
        type: 'content',
        duration: 5,
        narration: 'Let\'s explore the key features and benefits.',
        title: 'Key Features',
        subtitle: 'What makes it special'
      },
      {
        id: 'scene_3',
        type: 'conclusion',
        duration: 3,
        narration: 'Thank you for watching this educational video.',
        title: 'Conclusion',
        subtitle: 'Generated by InfoGraphAI'
      }
    ];
  }

  private async generateSubtitles(scenes: Scene[]): Promise<void> {
    let currentTime = 0;

    for (const scene of scenes) {
      if (!scene.narration) continue;

      // Create subtitle for the scene
      await prisma.subtitle.create({
        data: {
          videoId: this.videoId,
          text: scene.narration,
          startTime: currentTime,
          endTime: currentTime + scene.duration,
          position: 'BOTTOM_CENTER',
          animationType: 'FADE_IN',
          fontSize: 24,
          fontWeight: '500',
          color: '#FFFFFF',
          bgColor: 'rgba(0,0,0,0.8)'
        }
      });

      currentTime += scene.duration;
    }

    console.log(`[VideoGen] Generated ${scenes.length} subtitles`);
  }

  private async createSimpleFrames(scenes: Scene[]): Promise<void> {
    // Create output directory
    await fs.mkdir(this.outputDir, { recursive: true });

    // Create a simple HTML file representing the video content
    const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <title>Video: ${this.videoId}</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #1a1a2e;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    .scene {
      width: 90%;
      max-width: 800px;
      margin: 20px;
      padding: 40px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      animation: fadeIn 0.5s;
    }
    .scene h2 {
      font-size: 2.5em;
      margin: 0 0 20px 0;
      text-align: center;
    }
    .scene h3 {
      font-size: 1.5em;
      margin: 0 0 20px 0;
      text-align: center;
      opacity: 0.9;
    }
    .scene p {
      font-size: 1.2em;
      line-height: 1.6;
      text-align: center;
      opacity: 0.95;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <h1>Generated Video Content</h1>
  ${scenes.map(scene => `
    <div class="scene">
      ${scene.title ? `<h2>${scene.title}</h2>` : ''}
      ${scene.subtitle ? `<h3>${scene.subtitle}</h3>` : ''}
      <p>${scene.narration}</p>
      <small>Duration: ${scene.duration}s</small>
    </div>
  `).join('')}
  <p style="margin-top: 40px; opacity: 0.7;">
    Total Duration: ${scenes.reduce((sum, s) => sum + s.duration, 0)} seconds
  </p>
</body>
</html>`;

    // Save HTML preview
    const htmlPath = path.join(this.outputDir, 'preview.html');
    await fs.writeFile(htmlPath, htmlContent);

    console.log(`[VideoGen] Created preview at ${htmlPath}`);
  }

  private async createVideo(): Promise<string> {
    // Create public directory
    const publicDir = path.join(process.cwd(), 'public', 'videos');
    await fs.mkdir(publicDir, { recursive: true });

    // For now, create a placeholder video file
    const videoFileName = `${this.videoId}.mp4`;
    const videoPath = path.join(publicDir, videoFileName);

    // Check if ffmpeg is available
    try {
      await execAsync('ffmpeg -version');
      
      // Create a simple video with ffmpeg (black video with text)
      const ffmpegCmd = `ffmpeg -y -f lavfi -i color=c=black:s=1920x1080:d=10 -vf "drawtext=fontfile=/System/Library/Fonts/Helvetica.ttc:text='Video ${this.videoId}':fontcolor=white:fontsize=48:x=(w-text_w)/2:y=(h-text_h)/2" -c:v libx264 -pix_fmt yuv420p "${videoPath}"`;
      
      await execAsync(ffmpegCmd);
      console.log(`[VideoGen] Created video with FFmpeg`);
    } catch (error) {
      // If FFmpeg is not available, create a dummy file
      console.log(`[VideoGen] FFmpeg not available, creating placeholder`);
      await fs.writeFile(videoPath, Buffer.from('PLACEHOLDER_VIDEO'));
    }

    // Copy HTML preview to public directory
    const htmlSource = path.join(this.outputDir, 'preview.html');
    const htmlDest = path.join(publicDir, `${this.videoId}.html`);
    
    try {
      await fs.copyFile(htmlSource, htmlDest);
    } catch (error) {
      console.log('[VideoGen] Could not copy preview HTML');
    }

    // Clean up temp directory
    try {
      await fs.rm(this.outputDir, { recursive: true, force: true });
    } catch (error) {
      console.log('[VideoGen] Could not clean temp directory');
    }

    return `/videos/${videoFileName}`;
  }

  private async finalizeVideo(videoUrl: string): Promise<void> {
    // Get file stats if possible
    let fileSize = 0;
    try {
      const fullPath = path.join(process.cwd(), 'public', videoUrl.substring(1));
      const stats = await fs.stat(fullPath);
      fileSize = stats.size;
    } catch {
      fileSize = 1024 * 1024; // 1MB placeholder
    }

    // Update video record
    await prisma.video.update({
      where: { id: this.videoId },
      data: {
        status: 'COMPLETED',
        progress: 100,
        url: videoUrl,
        filename: path.basename(videoUrl),
        size: fileSize
      }
    });

    console.log(`[VideoGen] Video finalized: ${videoUrl}`);
  }

  private async updateVideoStatus(
    status: string,
    progress: number,
    error?: string
  ): Promise<void> {
    await prisma.video.update({
      where: { id: this.videoId },
      data: {
        status,
        progress,
        ...(error && { error })
      }
    });
  }
}

// Export function to start video generation
export async function startSimpleVideoGeneration(
  videoId: string,
  projectId: string,
  scenarioId?: string
): Promise<void> {
  const generator = new SimpleVideoGenerator(videoId, projectId, scenarioId);
  
  // Run in background
  setImmediate(async () => {
    try {
      await generator.generate();
    } catch (error) {
      console.error(`[VideoGen] Generation failed for ${videoId}:`, error);
    }
  });
}